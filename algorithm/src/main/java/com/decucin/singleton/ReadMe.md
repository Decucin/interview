# 线程不安全的单例模式
* 优点：思路简单，一想就想到了
* 缺点：多线程无法正常工作

# 饿汉式单例模式
* 优点：线程安全
* 缺点：未被使用的单例也会被创建，消耗资源多

# 双重校验锁的单例模式
* 优点：线程安全，只有使用时才会被创建
* 缺点：需要加锁，maybe效率低
* 核心：
  1. 构造方法私有(防止通过构造方法创建)
  2. instance用volatile修饰，防止指令重排列(new这一步正常是先申请内存再将其引用赋给instance，重排后可能先赋值再申请内存，那么其它线程就错了)
  3. DCL(双重校验锁，判断为null之后，可能其它线程已经完成了new操作导致此时instance != null, 那么就需要再检验一遍)

# 静态内部类的单例模式
* 优点：和DCL一样，同时实现更简单，同时无需加锁
* 原理：外部类被加载时instance不一定被初始化，只有SingletonHolder被主动使用，显式调用getInstance()时才会显式装载SingletonHolder类，从而实例化instance(注意两个final)

# 枚举的单例模式
maybe最佳实践
避免多线程问题，自动支持序列化，防止反序列化创建新的对象，绝对防止多次实例化，不能通过reflection attack调用私有构造方法