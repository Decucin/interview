# 自动内存管理
## 运行时数据区
- 程序计数器：指示字节码的行号，是程序控制流的指示器，运行的是Java方法记录正在执行的字节码指令地址，本地方法则值是Undefined，唯一一个无OOM的区域，线程私有
- Java虚拟机栈：描述Java方法的线程内存模型，方法被执行对应一个栈帧被创建，栈帧中有局部变量表、操作数栈、动态链接、方法出口等，局部变量表中的变量是以局部变量槽(Slot)的形式展示的，但8个字节的数据类型，long, double占用两个槽，局部变量表的空间(槽的数量)在**编译**时已经确定，规定了两类异常OOM(在运行动态扩展时可能发生，但Hotspot不允许动态扩展，所以出现此问题只可能在申请栈空间时出现)以及SOF，线程私有
- 本地方法栈：与虚拟机栈类似但在运行Native方法是被创建，maybe和Java虚拟机栈合二为一，也有可能OOM以及SOF，线程私有
- 堆：在虚拟机启动时被创建，大多数对象在这里被创建(存在栈上分配以及标量替换)，也叫GC堆，堆所有线程共享，但是存在线程私有分配缓冲区(Thread Local Allocation Buffer, TLAB)用于提升对象分配时的速度。堆可以物理上不连续，但逻辑上应该被视为连续，此外大对象的实现一般需要连续的内存空间，堆中没有完成实例分配同时堆也无法再扩展时会OOM
- 方法区：所有线程共享，存储被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等，也叫Non-Heap，用于和堆区分开，会OOM
  - 之前的永久代实现是方法区，但永久代有最大上限，容易OOM
  - JDK6考虑移除方法区改为本地内存实现
  - JDK7将永久代中的字符串常量池、静态变量等移出
  - JDK8放弃永久代，改为本地内存中实现的元空间(Metaspace)，其中含有JDK7中未移出的信息，主要是类型信息，这里甚至可以不需要垃圾回收
运行时常量池也是方法区的一部分，主要含有常量池表(编译器产生的字面量以及符号引用，可能还有直接引用)，这里的东西其实时动态的，比如String类的intern()，会OOM

此外还有一部分被频繁使用但不属于运行时数据区的内存－－直接内存，NIO中可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为引用进行操作，可以避免在Java堆以及Native堆中拷贝数据产生的开销，这部分内存大小不会受Java堆限制但是会受本机总内存(物理内存、SWAP分区或者分页文件)大小以及处理器寻址空间的限制

## 对象的创建
1. 先检查常量池中是否有类的符号引用
2. 没有则需要先进行类加载过程
3. 有则需要对对象分配内存
   - 指针碰撞：内存是规整的，一部分是使用的，另一部分是未使用的，有一个指针作为两部分区域的分界点，移动这个分界点即可
   - 空闲列表：一个列表中记录了空闲的内存块，分配的时候找到一块足够大的内存空间划分给对象实例
   - 具体使用以上两种内存分配方式取决于堆是否规整，即垃圾收集器是否启用了空间压缩整理的能力
   - 此外，分配空间在并发情况下并不是线程安全的，有两种处理方式，CAS失败重试以及TLAB(哪个线程需要分配内存，就现在其TLAB中分配，TLAB用完了在分配新内存时才CAS失败重试)
4. 将分配到的内存空间初始化零值，使用TLAB则可在TLAB分配时完成
5. 进行必要设置，将对象的信息，如对应的类型、如何找到类的元数据信息、对象hash(第一次调用hashcode()才会被计算)、GC分代、锁信息等存放在对象头
6. 执行< init >()方法   --> 构造函数

## 对象的内存布局
### 对象头(Header)
- 用于存储对象自身的运行数据(hash码, GC分代年龄, 锁状态标志位, 线程持有的锁, 偏向线程ID, 偏向时间戳)    --->    Mark Word（动态定义，根据对象状态复用地址空间）
- 指向对象的类型元数据的类型指针(但这块不是一定的，有的虚拟机实现中对象头中并没有对象的类型指针)
- 如果是数组，还有一块用于记录数组长度(用于推断数组大小，确定Java对象的大小)
### 实例数据(Instance Data)
对象真正存储的有效信息  --->    字段内容(包含从父类中记录下来的)
### 属性填充(Padding)
Hotspot要求任何对象都必须是8字节的倍数，没有对其则通过padding填充
这里为什么要求是8字节的整数倍，找到的有两个原因，一是为了压缩指针时使用都是8的倍数，那么可以把二进制里面的后三位取消，即左移或者右移三位时能够做到这一点，如8(1000) ->  1(1), 16(10000)  -> 2(10)，这样，那么理论上原本可以表示4G的内存现在可以表示32G；第二个原因，大部分都是64位系统，一次读取64bit，即8字节

## 访问对象的方式
通过栈上的reference数据来操作堆上的具体对象
- 句柄：堆中可能有一块句柄池存储了对象的句柄地址，reference包含了对象实例数据以及实例数据各自具体的地址信息，好处是对象被移动时修改示例数据指针即可，reference本身不需修改
- 直接指针：堆的内存布局需要考虑如何放置访问类型数据的相关信息，reference存储对象地址，好处是速度快，节省了一次指针定位的开销(Hotspot主要使用这个)

# 垃圾收集器与内存分配策略
## 垃圾收集器的任务
1. What
   * 对于线程独有的部分，这些内容随线程的创建而产生，线程结束而消亡，故无需GC
   * 堆和方法区则不一样，故这两部分是垃圾收集器管理的部分
2. When
   * 引用计数法：在对象中添加一个计数器，有一个地方引用时计数器+1，失效时-1，0则不可能再被使用  -->  优点：原理简单，效率高；缺点：有额外情况需要处理(循环引用很麻烦)
   * 可达性分析法：通过GC Roots向下搜索形成引用链，若是有的对象到GC Roots没有引用链相连，那么需要被GC。  -->  主流
可作为GC Roots的基本对象：
   * 虚拟机栈(栈帧中的本地变量表)中引用的对象：各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等
   * 方法区中被类静态属性引用的对象：Java类的引用类型静态变量
   * 方法区中常量引用的对象：字符串常量池里的引用
   * 本地方法栈中JNI引用的对象
   * Java虚拟机内部的引用：基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器
   * 被同步锁(synchronized)持有的对象
   * 反应Java虚拟机内部情况的JMXBean, JVMTI注册的回调, 本地代码缓存等
   * 其他的可能会被临时性假如其中
3. How

## 引用
* JDK1.2之前：如果reference类型的数据中存储的数值是另外一块内存的地址就称为引用
* 之后对引用进行了扩充：强引用、软引用、弱引用、虚引用

1. 强引用
无论任何情况下，只要强引用关系存在，垃圾回收器用友不会回收掉被引用的对象  --> 引用赋值
2. 软引用
系统将要发生内存溢出时这些内陷会被回收  --> 缓存
3. 弱引用
只能存活到下一次垃圾收集发生为止  --> ThreadLocal
4. 虚引用
不会对被引用对象产生影响同时无法通过虚引用取得对象实例  --> 在对象被回收时得到一个通知(方便管理堆外内存)

## "缓刑"
1. 可达性分析后，被判定为不可达对象，此时是其第一次被标记，之后进行一次筛选，判断该对象是否有必要执行finalize() (没有重写该方法或者该方法被调用过则不需执行)
2. 需要执行该方法的对象会被放置在F-Queue队列中，并在之后由一条虚拟机自动建立，调度优先级比较低的Finalizer线程去执行对应方法，但是只是让该方法开始，不承诺；一定会等待其运行结束(防止该方法执行慢或者死循环导致队列中其他对象的方法无法被执行)
3. 该方法执行后，收集器会对F-Queue中的对象进行第二次小规模标记，判定是否需要被GC

## 方法区的回收
主要的回收类型：废弃的常量、不再被使用的类型
1. 废弃的常量
某个字符串曾进入过常量池但现在没有任何对象引用该常量，同时也没有其它地方引用此字面量
2. 不再被使用的类型
   * 所有实例都被回收
   * 该类的类加载器已被回收
   * 对应的Class对象没有在任何地方被引用
   * 满足以上条件仅是被允许，是否对类型进行回收可以通过-Xnoclassgc控制

## 垃圾收集算法
分代假说：
1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
基于以上分代假说，一般采取的是：将堆分为不同区域，将对象根据年龄分到不同区域存储(划分为年轻代和老年代)
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数(防止每次GC都要遍历老年代)
在新生代上建立一个全局数据结构(记忆集Remembered Set)。该结构把老年代划分成若干块，标识出老年代的哪一块会存在跨代引用，此后若是Minor GC，那么包含跨代引用的那一块才会被加入到GC Roots扫描

对收集的定义：
* 部分收集(Partial GC)：不完整收集整个堆
    * 新生代收集(Minor GC/Young GC)：目标是新生代
    * 老年代收集(Major GC/Old Gc)：目标是老年代(CMS有)
    * 混合收集(Mixed GC)：目标是整个新生代和部分老年代(G1)
* 整堆收集(Full GC)：收集整个Java堆和方法区

### 标记——清除
1. 标记所有需要回收的对象
2. 统一回收掉所有被标记的对象
3. 当然也可以反过来，标记存活的，回收未被标记的

缺点：
* 执行效率不稳定：标记、清除的效率随对象增长而降低
* 内存碎片：产生大量内存碎片，碎片太多可能导致之后需要分配大对象时无法找到足够的连续内存而提前触发另一场垃圾收集

### 标记——复制
1. 将可用内存分为大小相等的两块，每次使用一块
2. 被使用的那块内存使用完成之后，将存活的对象复制到另外一块上
3. 把之前的那块内存一次性清理掉

缺点：
* 如果多数对象是存活的，那么会产生大量内存复制的开销
* 可用内存缩减为原来的一半

Appel式回收
1. 把新生代划分为一块较大的Eden和两块较小的Survivor
2. 分配时只使用Eden和一块Survivor
3. 回收时将Eden和使用的那块Survivor中存活的对象一次性复制到另一块Survivor
4. 清理掉Eden区和使用过的Survivor
5. Eden和Survivor默认是8：1，每次使用90%
6. 若是Survivor的空间(10%)无法容纳，那么需要依赖其他区域(老年代)进行分配担保：没有足够空间存放上次存活下来的存活对象，那么这些对象会通过分配担保机制直接进入老年代

### 标记——整理
1. 标记所有需要回收的对象
2. 让所有存活对象向内存的一端移动
3. 清理掉边界之外的内存

缺点：
* 内存回收时需要进行移动，STW(Stop The World)

和稀泥方法
1. 多数时间标记——清除，容忍碎片
2. 内存碎片影响大对象分配时采用标记——整理清理一次，获得规整的空间(CMS)

## HotSpot垃圾收集器
* Young generation: Serial, ParNew, Parallel Scavenge
* Tenured generation: CMS, Serial Old, Parallel Old
* G1
* 配合使用：Serial + Serial Old, ParNew + CMS(+ Serial Old), Parallel Scavenge + Serial Old, Parallel Scavenge + Parallel Old, G1
  ![配合使用](https://blogs.oracle.com/jonthecollector/our_collectors)
### Serial
* 新生代复制算法暂停所有用户线程(单一GC线程)
* 客户端模式下默认新生代收集器
* 简单而高效：额外内存占用最小，单线程无需线程切换

### ParNew
* 新生代多条线程垃圾收集(并行收集)，暂停所有用户线程
* 其余与Serial一致
* 除了Serial之外唯一能和CMS协同工作的收集器

### Parallel Scavenge
* 新生代多条GC线程(并行收集)，复制算法暂停所有用户线程
* 达到可控的吞吐量: 用户代码运行时间 / (用户代码运行时间 + 垃圾收集运行时间)，此收集器可以使用自适应调节策略调节堆的各种参数

### Serial Old
* Serial的老年代版本
* 单线程收集，标记——整理，暂停所有用户线程
* 主要提供给客户端模式下的虚拟机使用，若是在服务端用，要么和Parallel Scavenge配合使用，要么CMS并发收集失败(Concurrent Mode Failure)时使用

### Parallel Old
* Parallel的老年代版本
* 多线程并发收集，标记整理算法，暂停所有用户线程
* 吞吐量优先

### CMS
* 回收停顿时间最短
* 过程：
  1. 初始标记：标记GC Roots直接关联的对象，很快，STW
  2. 并发标记：从直接关联对象遍历整个对象图，耗时长但无需暂停用户线程
  3. 重新标记：因2中用户线程继续工作，导致标记产生变动(增量更新)，暂停时间比1稍长但远比2短
  4. 并发清除：清理掉死亡对象，和用户线程并发
* 缺点：
  1. 资源敏感：不会导致用户线程暂停，但是会因为占用处理器计算能力导致应用程序变慢，降低总吞吐量，随着核心数量增加而降低
  2. 无法处理浮动垃圾：并发标记以及并发清除阶段产生的对象只有等下一次GC(对象朝生夕灭)(对于这部分可能会产生的对象，需要分配预留空间)，CMS运行期间若是预留空间不足会导致并发失败，之后使用Serial Old重新进行老年代回收
  3. 产生大量空间碎片：标记——清除，这会导致还有空间但是不连续，分配大对象时空间不足进行Full GC空间整理

### Garbage First(G1)
* JDK9之后服务端默认的垃圾回收器
* 把连续的Java堆划分为多个大小相等的独立空间区域(Region)
* 每个Region都可作为Eden, Survivor, 老年代
* 特殊的Humongous专门存储大对象
* 过程如下：
  1. 初始标记：标记GC Roots直连的对象，修改TAMS的值，需要停顿用户线程但耗时很短，而且是借用Minor GC时同步完成
  2. 并发标记：进行可达性分析，扫描对象图，耗时长但可与用户线程并发，重新处理SATB记录在并发下有引用变动的记录
  3. 最终标记：暂停用户线程，处理2过程留下的少量SATB记录
  4. 筛选回收：更新Region统计记录，对Region排序，制定回收计划，任意选择Region进行回收，把需要回收的Region中的存活对象复制到空Region中，清理掉整个旧Region，暂停用户线程但多条GC线程并行执行
* 核心问题如下：
  1. 跨Region的引用如何解决：每个Region有自己的记忆集，每个记忆集存有其它Region指向本Region的指针，并标记这些指针在哪些卡页中(记忆集本质上是一个Hash表，key是别的Region的起始地址，Value是一个集合，存储了卡表的索引号)，导致了更高的内存占用
  2. 并发标记阶段如何保证GC线程与用户线程互不干扰(两方面内容)：一是用户线程改变引用时不能打破原本的对象图结构，通过原始快照实现，二是新创建的对象如何分配内存，通过在每个Region中设置两个TAMS(Top at Mark Start)指针，新生成的对象在这里分配地址，默认其存活
  3. 如何建立预测模型：衰减均值理论，记录每个Region的回收耗时、脏卡数量等，统计状态越新，越能决定回收价值

CMS与G1的比较：
* G1不会产生空间碎片，可以制定最大停顿时间，分Region布局
* G1的卡表更复杂，内存占用更高(CMS只要一份，同时只需要处理老年代到新生代的引用)，执行负载也更高(CMS只使用写后屏障，G1还要使用写前屏障)

### Shenandoah
* 非官方，Oracle通过条件编译排除了其代码，只在OpenJDK中有
* 类似G1，但有改进：
  1. 支持并发收集
  2. 默认不使用分代收集
  3. 用连接矩阵代替记忆集记录跨Region引用
* 过程如下：
  1. 初始标记：标记与GC Roots直连的对象，STW
  2. 并发标记：遍历对象图，标出全部可达对象，与用户线程并发执行
  3. 最终标记：处理剩余的SATB，统计价值最高的Region，构成一组回收集，有短暂的停顿
  4. 并发清理：清理没有一个存活对象的Region
  5. 并发回收：把Region中的存活对象复制到其它未被使用的Region中(注意此时用户线程是继续运行的，收集器通过读屏障(后面希望改为引用访问屏障)和转发指针(对象头多一个Brooks Pointer，原本指向自己，之后指向要转发的地址，类似句柄)完成)
  6. 初始引用更新：建立一个线程集合点，确保5已经完成，有短暂停顿
  7. 并发引用更新：把堆中所有指向旧对象的引用修正到复制后的新地址，按照内存物理地址的顺序线性搜索即可
  8. 最终引用更新：修正存在与GC Roots的引用，短暂停顿
  9. 并发清理：回收整个回收集中的Region

### ZGC
* 基于Region布局，分为大(容量动态变化但必须是2MB的整数倍，放置4MB以上的大对象), 中(容量固定为32MB，存放大于等于256KB但小于4MB的对象), 小(容量固定为2MB，放置小于256KB的对象)
* 过程：
  1. 初始标记：标记GC Roots直连对象，STW
  2. 并发标记：可达性分析并初始标记、最终标记短暂停顿，标记过程实际就是更新染色指针的Marked 0, Marked 1位
  3. 并发预报重分配：得出本次需回收哪些Region，组成重分配集
  4. 并发重分配：把重分配集中的存活对象复制到新Region上，为该集中的每个Region设立一个转发表记录就对象到新对象的转发关系(指针自愈：访问发现此对象处于重分配集，那么会被读屏障拦下并访问到新复制的对象，同时修改该引用的值，使其直接指向新对象)
  5. 并发重映射：修正整个堆中指向重分配集中旧对象的引用(因为指针可以自愈，故把这个步骤合并到并发标记阶段)
* 核心是如何实现并发整理——指针染色
64位系统中理论可访问2^64字节的内存，但AMD64架构中最多只支持52位地址总线和48位虚拟地址空间，此外操作系统也会限制，故64位Linux只支持47位进程虚拟地址空间和46位物理地址空间，那么把这46位的高四位拿出分别记为Finalizable(只能通过finalize()访问)，Remapped(是否进入了重分配集(是否被移动过))，Marked 0, Marked 1(三色标记状态)
为什么可以这样呢？因为这些标记只于引用有关，与对象本身无关
* 染色指针的三大优势
  1. 存活对象被移走后可以马上被释放或者重用
  2. 大幅减少垃圾收集过程中内存屏障的使用情况(只使用读屏障)
  3. 染色指针日后也可扩展
* 问题：染色指针操作系统是否支持
* 还有一个优点：支持"NUMA-Aware"(为多处理器或多核处理器所设计的内存架构)内存分配，优先尝试在请求线程当前所处的处理器本地内存上分配对象以保证高效内存访问

# 虚拟机执行
## 类加载
加载 验证 准备 解析 初始化 使用 卸载(验证、准备、解析统称为连接)

### 加载
- 通过一个类的全限定类名来获取定义此类的二进制字节流(压缩包读取、网络获取、计算产生、其他文件生成、数据库读取、加密文件获取...)
- 将此二进制流代表的静态存储结构转化成方法区的运行时数据结构
- 在内存中生成一个代表该类的Class对象，作为方法区各种数据结构的访问入口

非数组类的加载使用类加载器，可以重写一个类加载器的findClass()或loadClass()方法实现获取代码的动态性，数组类的加载不通过类加载器，而是由虚拟机直接在内存中动态构造出来，但是数组对应的元素类型需要通过类加载器进行加载，创建遵循以下规则：元素类型是引用类型，数组将被标识在加载该元素的类加载其的类名称空间上，若不是引用类型(int[])标记为与引导类加载器想关联，此外数组类的访问性与元素类型的访问性一致，若是int[]则默认为public

**加载和连接是交叉进行的，可能加载尚未完成，但连接已经开始**

### 验证

确保Class文件的字节流中包含的信息符合虚拟机规范，被当作代码运行后不会危害虚拟机自身的安全
- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证(发生在解析阶段)

### 准备

为类中定义的静态变量(static修饰)在方法区分配内存并设置初始值(一般为0值，如果是final修饰，即常量，会被设置为对应的值)，对于HotSpot来说，JDK7之前在永久代，之后在Java堆中

### 解析

将常量池的符号引用转变为直接引用的过程
- 符号引用：以一组符号描述所引用的目标，使用时无歧义定位到即可
- 直接引用：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄

这里会把部分方法(也叫非虚方法，包括共有静态方法、私有方法、实例构造器、父类方法、被final修饰的方法)的符号引用转变为直接引用，

### 初始化
执行类构造器<cinit>()的过程。

<cinit>()的生成是编译器自动收集类中所有类变量的赋值动作以及静态语句块中的语句合并产生，静态语句块只能访问到定义在其之前的变量，定义在其之后的变量，可以访问但不能赋值，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<cinti>()，接口也有此方法，但无需像类一样，执行此方法前需要完成父类(对于接口来说就是父接口)的此方法，接口的实现类在初始化时也不会执行接口的此方法，同时虚拟机需要让此方法被正确的加锁同步

初始化的时机(主动引用)：
1. 遇到new getstatic putstatic invokestatic这四条字节码指令
2. 对类型进行反射调用的时候
3. 初始化类时发现其父类未被初始化，先触发父类的初始化
4. 虚拟机启动时先初始化主类
5. 如果一个MethodHandle实例最后的解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic, REF_newInvokeSpecial四种类型的方法句柄，并且方法句柄对饮的类未进行过初始化
6. 接口定义了default方法，那么在接口的实现类初始化之前先完成接口的初始化

未被初始化(被动引用)：
1. 对于类中定义的静态字段，只有定义此字段的类会被加载，父类定义了静态变量，子类只使用该静态变量时不会触发子类的初始化，至于加载和验证阶段是否触发，具体取决于虚拟机实现，对于HotSpot会导致子类加载
2. 新建对象数组不会触发对应类的初始化，因为这是通过newarray进行创建的(同时能够使用的方法也只有length属性和clone()方法)
3. 如果只使用类中定义的常量，那么也不会触发类的初始化(编译阶段已经将常量的值放入类的常量池中)

**这里有个东西，类初始化时其父类必须全部初始化过，但是接口在初始化时不要求其父接口全部完成了初始化，只有真正使用到父接口时才会初始化**

## 类加载器

确定两个类相等的前提条件是：同一个类加载器加载的

### 三层类加载器

- 启动类加载器(Bootstrap Class Loader)：负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且名字需要Java虚拟机能够识别，该加载器无法被加载程序调用，如果需要把类委派给启动类加载器进行加载，直接用null代替即可
- 扩展类加载器(Extension Class Loader)：以Java代码形式实现，负责加载<JAVA_HOME>\lib\ext目录，或者被java.ext.dirs系统变量所指定的路径中的所有类库
- 引用程序类加载器(Application Class Loader)：加载用户类路径下所有类库，如果程序没有自定义类加载器，那么一般情况下这个就是程序中默认的类加载器

### 双亲委派模型

除了顶层的启动类加载器外，其余的加载器都应有自己的父类加载器，父子关系一般以组合方式进行代码复用

模型的工作过程是： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是会把请求委托给自己的父类加载器去完成，故所有的类加载请求最终应该传送到最顶层的启动类加载器进行加载，当父类加载器反馈无法完成此次加载请求时，子加载器才会尝试自己完成加载

好处是：类随着它的类加载器一起伴有一种优先级关系，如java.lang.Object最终都是委托给最顶层的启动类加载器进行加载，反之则是会导致程序中出现不同的Object类，代码混乱不堪

OSGi加载顺序：
1. 以java.*开头以及在委派列表里的类交给父类加载器进行加载
2. 将Import列表中的类交给Export此类的Bundle的类加载器加载
3. 查找当前Bundle的ClassPath，使用自己的类加载器加载
4. 查找类是否在自己的Fragment Bundle中，在就委派给Fragment Bundle的类加载器加载
5. 查找Dynamic Import的Bundle，委派给对应Bundle的类加载器加载
6. 否则类查找失败

# 字节码的执行

每一个方法从调用开始到执行结束的过程，都对应一个栈帧在虚拟机里面从入栈到出栈的过程
一个栈帧需要分配多少内存，不会受运行期变量数据的影响，而仅仅取决于程序源码和具体的悉尼及实现栈内存的布局形式

## 栈帧

局部变量表、操作数栈、动态链接、方法返回地址、其余额外信息

### 局部变量表
存放了方法的参数以及其中定义的局部变量，以变量槽为最小单位，每个变量槽都应该能够存放boolean, byte, char, short, int, float, reference, returnAddress类型的数据，long和double采用高位对齐的方式使用两个变量槽进行存放，注意变量槽是允许重用的

虚拟机采用索引进行变量表中的定位，索引从0开始，如果是一个变量槽保存的，那么索引为n标识使用第n个变量，两个变量槽保存的，那么索引为n标识使用n和n+1共同保存的变量，同时不允许单独访问其中的一个

方法被调用时，使用局部变量表完成从实参到形参的传递，如果是实例方法，那么局部变量表中第0位索引默认用于传递方法所属实例对象的引用，类似于this，之后按顺序(定义的顺序)分配参数列表以及定义的变量

### 操作数栈

编译时最大深度已经被写在code属性中，32位数据类型栈容量为1，64位容量为2。方法执行时为空，伴随着字节码指令的写入和提取对应入栈和出栈操作，部分虚拟机在实现时有可能把下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，在方法调用时可以共享一部分数据

### 动态链接

栈帧中包含一个指向运行时常量池中关于该栈帧所属方法的引用，为了支持动态链接。符号引用的解析一部分在类加载阶段完成，称为静态解析，一部分在运行期间转化为直接引用，叫做动态链接

### 方法返回地址

方法执行后有两种退出方式：
- 在方法执行完毕后正常返回(正常调用完成)：主调方法的PC计数器的值
- 方法执行过程中遇到了异常，并且该异常没有在方法中被处理(异常调用完成)：通过异常处理器表来确定，栈帧中不会保存对应信息

方法退出需要执行的操作：恢复上层方法的局部变量表和操作数栈，如果有返回值，将其压到操作数栈顶部，调整PC计数器的值以使其指向方法调用的后一条指令

### 附加信息

eg: 与调试、性能收集相关的信息

## 方法调用
- 
- 解析调用，解析阶段把符号引用转变为直接引用
- 分派调用：静态非静态，单分派多分派

### 静态分派

依赖静态类型来决定方法的执行版本的分派动作(eg 方法重载)，在编译器完成，选择一个“相对合适”的(比如对于一个方法，有Integer和int两个重载版本，传入3时选择int的版本，char > int > long > float > double > Character > Serializable > Object > 变长参数)

### 动态分派

重写，方法调用对应的字节码指令是invokevirtual，该指令的解析步骤是：找到操作数栈第一个元素所指向对象的**实际类型**，记为C，若是在C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，通过则返回该方法的直接引用，结束，否则返回异常，没有找到则按照继承关系进行搜索和验证，最终没有找到则抛异常

### 单分派和多分派

方法的宗量：方法的接收者与方法的参数

- 单分派：根据一个宗量对方法进行选择
- 多分派：根据多余一个宗量对方法进行选择

JAVA——静态多分派，动态单分派的语言

动态分配的实现：存在虚方法表和接口方法表，表中含有对应的方法的实际入口地址，若是某个方法在子类中没有被重写，那么子类的虚方法地址入口和父类一致，都指向父类的实现入口，重写的话地址会被替换，相同签名的方法在父子类中索引序号应该一致，类型变更时只需更改查找的方法表即可，表在类加载的连接阶段进行初始化

# 并发
## JMM(Java内存模型)

所有的变量都存储在主内存中，每条线程有自己的工作内存，线程的工作内存中保存着该线程使用的变量的主内存副本(不会把整个对象复制一次，会复制引用或者具体使用的某个字段)，线程对变量的所有操作(读写)都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间也不能直接访问对方的工作内存，变量值的传递需要通过主内存完成

Java虚拟机需要保证以下操作是原子的(double, long的部分操作可以例外):
- lock: 把**主内存**的变量标识为被某线程独占的状态
- unlock: 把**主内存**的变量从被线程独占的状态接触
- read: 把**主内存**的变量的值传输到线程的工作内存，便于之后的load操作
- load: 把read操作从主内存中获得的值放入到**工作内存**的变量副本中
- use: 把**工作内存**中变量的值传给执行引擎
- assign: 把从执行引擎接受的值赋给**工作内存**的变量
- store: 把**工作内存**中一个变量的值传送到主内存中，以便随后的write操作
- write: 把store操作从工作内存中得到的变量值放入到**主内存**的变量中

eg: 从主内存拷贝到工作内存，先read, 后load，但不要求连续，即能够插入其余指令。

此外对于上述操作还有对应的规则：
- 不允许read和load，store和write操作之一单独出现
- 不允许一个线程丢弃它最近的assign操作
- 不允许一个线程无原因的(即变量没有改变，没有执行过赋值操作)把数据从线程的工作内存同步回主内存
- 不允许直接在工作变量中直接使用一个未被初始化的变量(use, store之前必须有load和assign)
- 变量在同一时刻只允许一条线程对其进行lock操作，但同一线程能lock多次(对应的必须也unlock对应次数)
- lock操作会清空工作内存中此变量的值，执行引擎使用前需要重新load和assign
- unlock能且只能对本线程lock的变量执行
- unlock之前需要把变量同步回主内存中(store, write)

volatile修饰的变量有以下特性：
- 可见性：某条线程修改了变量的值，新值对其余线程立即可知，但由于运算操作符并非原子操作，故volatile变量在并发下是不安全的(若使用volatile, 要满足运算结果不依赖变量的当前值，或者确保只有单一线程会对变量进行修改，此外变量不需要与其它的状态变量共同参与不变约束)
- 禁止指令重排序：

对于volatile有一些特殊规则(假设V和W是两个volatile变量，T是一个线程)：
- 线程T对变量V的use动作可以认为和其对V的load，read操作相关联，必须连续且一起出现(即每次读都要从主内存中拿)
- 线程T对变量V的assign动作可以认为和其对V的store, write操作想关联，必须连续且一起出现(即每次写都要立刻同步到主内存中)
- 若动作A是T对V的use或者assign，动作F是和A相关联的load和store，P是和F相应的对V的read和write，同时B是T对W的use和assign，G是和B相关联的load或者store，Q是和G相应的对W的read和write，那么如果A先行与B，那么P先行与Q(不会被指令重排序而优化)

对于long和double的特殊规则：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两个32位的操作(如果多个线程共享一个未被声明为volatile的long或double类型的变量，并且对他们进行读写操作，那么某些线程可能会读到一个即不是原值，也不是其它线程修改的值)，HotSpot可以通过-XX:+AlwaysAtomicAccesses保证虚拟机对所有类型都是原子性访问

## 原子性、可见性、有序性
- 原子性： 操作有read, load, assign, use, store, write, lock, unlock，对应于Java关键字，synchronized块之间的操作具备原子性
- 可见性：当一个线程修改了共享变量的值时，其它线程能够立刻得知这个修改。实现：修改后将新值同步回主内存，读取前从主内存刷新变量值，对应于Java关键字，synchronized, volatile, final实现可见性
- 有序性：本线程内观察，所有操作都是有序的(线程内似表现为串行的语义，Within-Thread As-If-Serial Semantics)；另一线程中观察，所有操作都是无序的(指令重排序以及工作内存与主内存同步延迟)，对应于Java关键字，synchronized, volatile实现有序性

## 先行发生原则
- 程序次序规则：同一个线程内书写在前面的操作先行发生于书写在后面的操作
- 管程锁定规则：unlock操作先行发生于对同一个锁的lock操作
- volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
- 线程终止规则：线程中所有操作都先行发生于对此线程的终止检测(可以用Thread::join()是否结束，Thread::isAlive()返回值检测线程是否终止)
- 线程中断规则：线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断发生(用Thread::interrupted()检测到是否有中断发生)
- 对象终结规则：对象的初始化完成先行发生于它的finalize()方法开始
- 传递性：A先行发生于B，B先行发生于C，那么A先行发生于C

**时间上先发生不代表这个操作先行发生，反之也不成立。**

## 线程
实现线程的三种方式：
- 使用内核线程实现(1:1): 操作系统内核支持的线程，线程切换、调度由内核的操纵调度器完成，一般不会直接使用，而是使用一种高级接口——轻量级进程，每个轻量级进程都由一个内核线程支持。局限性：各种线程操作都需要系统调用，要消耗一定的内核资源，故一个系统支持轻量级进程的数量是有限的
- 使用用户线程实现(1:N): 广义：不是内核线程，狭义：完全建立在用户空间的线程库上，内核无法感知到其存在以及如何实现。优劣势都在于没有系统内核的支持
- 使用用户线程+轻量级线程混合实现(N:M): 既存在用户线程，也存在轻量级进程

Java实现线程的方式因具体虚拟机不同，HotSpot是每个Java线程映射到一个操作心态原生线程

线程调度的方式：
- 协同式线程调度: 执行时间由线程本身来控制，自己的工作执行完之后主动通知系统切换到另一个线程上，好处是实现简单，同时一般不会出现线程同步问题，坏处是执行时间不可控制，如果代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞
- 抢占式线程调度: 执行时间由系统分配，切换也不由线程决定，执行时间系统可控，不会出现一个线程阻塞导致整个进程阻塞，Java也是此类

Java定义的线程状态：
- 新建：创建之后未启动的线程
- 运行：对应操作系统状态为Running和Ready，可能正在执行，也可能等待操作系统为它分配执行时间
- 无期限等待：不会被分配处理器时间，要被其它线程显示唤醒(没有设置时间的Object::wait(), 没有设置时间的Thread::join(), LockSupport::park())
- 期限等待：不会被分配处理器时间，但是在一定时间内会由系统自动唤醒(Thread::sleep(), 设置了时间的Object::wait(), 设置了时间的Thread::join(), LockSupport::parkNanos(), LockSupport::parkUntil())
- 阻塞：线程被阻塞，等待获取一个排他锁
- 结束：已终止的线程状态

线程切换的开销：响应中断、保护和恢复执行现场(A切换到B：中断，把线程A的上下文数据妥善保管好，把寄存器、内存分页恢复到B挂起时候的状态，涉及一系列数据在各种寄存器之间的来回拷贝)

协程：用户线程，可能是协同式调度，好处是占的容量小，并发的协程可达数以十万记，局限性是应用层面需要实现的东西很多

## 线程安全

定义：当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其它的协调操作，调用这个对象的行为都能获得正确的结果，那么就称这个对象是线程安全的

Java语言下各种操作共享的五类数据：
- 不可变：不可变对象一定线程安全，无论是对象的方法实现还是方法的调用者都不需进行任何保障措施(前提是没有发生this指针逃逸)。对于基本数据类型，final修饰；对象类型，自行保证行为不对其进行修改，例如String类
- 绝对线程安全：满足线程安全的定义
- 相对线程安全：通常意义上说的线程安全，即对此对象的单次操作是安全的，调用时不需要额外的保障措施，但对一些特定顺序的连续调用，需要使用额外手段保证调用的正确性,Vector等类
- 线程兼容：方法本身并不是线程安全，但可以通过在调用端正确地使用同步手段保证对象并发环境可用，HashMap之类
- 线程对立：不管调用方如何使用，都无法在多线程中使用

线程安全的实现方法：
- 互斥同步(悲观)：同步是指在多个线程并发访问共享数据时，保证数据在同一时刻只被一条或一些(信号量)线程使用，互斥是实现同步的一种手段，临界区、互斥量、信号量都是常见的互斥实现方式，对应Java就是synchronized关键字，字节码层面，会在代码块前后形成monitorenter和monitorexit，如果synchronized关键字有参数，那么对应的就是锁定的对象，若是方法的锁定，则根据方法为实例方法或者类方法来决定锁的是代码所在的对象实例还是对应的Class对象。遇到monitorenter指令时，先获取对象的锁，若是该对象没有被锁定或者已经持有了锁(这表明锁是可以重入的)，那么锁的计数器+1，对应的monitorexit则-1，计数器值为0则将其释放，如果获取失败，则当前线程应该阻塞等待(无条件阻塞后面线程的进入，无法强制获得锁，也无法强制想获得锁的线程退出)；此外还有Lock接口，最常见的实现是ReentrantLock，同样可重入，但等待可中断(持有锁的线程长期不释放时，正在等待的线程能够选择放弃等待转为做其他事情)、可以实现公平锁(多个线程等待锁时会按照申请锁的时间顺序来依次获得锁，反之非公平锁就是释放锁时其余等待的线程获得锁的概率是一致的)、能绑定多个条件(一个Lock能绑定多个Condition)，但是synchronized足够简单，无需显示释放锁。
- 非阻塞同步(基于冲突检测的乐观并发策略)：先进行操作，若是没有其它线程争用共享数据，那么操作就直接成功了，反之则进行补偿策略，常见的就是一直不断尝试，但是需要硬件保证操作的原子性，如CAS：需三个参数内存位置V、旧的参数值A、准备设置的新值B，当切仅当V中的值是A时，用B更新A的值，反之不更新，但无论如何都要返回V处的原值，存在ABA问题(原本读到A，后来赋值时也是A，但其实中间经历了从A到B再到A的过程)
- 无同步方案：部分代码天生线程安全，如可重入代码(在代码执行的任何时刻可以中断然后去执行其它代码，在控制权返回后不会出现任何错误)，线程本地存储(把共享数据的可见范围限制在一个线程之内，使用ThreadLocal实现，每个线程的Thread对象中都有一个ThreadLocalMap对象，存储了一组以ThreadLocal.threadLocalHashCode为键，本地线程变量为值的K-V对，ThreadLocal对象就是当前线程ThreadLocalMap的访问入口)

## 锁优化
- 自旋锁：用户态、内核态的切换开销太大了，在这段时间恢复和挂起线程并不值得，可以让请求锁的线程等待一会(自旋)，看持有锁的线程是否会很快释放，坏处是占用时间长的话，自旋只会平白消耗处理器性能，默认自旋次数是10(可以使用-XX:PreBlockSpin来自行更改，之后有自适应自旋锁，即对于一个锁对象，如果上次通过自旋获得了锁，那么允许其自旋更长时间，反之则有可能省略掉自旋过程)，超过了10次就会使用传统的方式把该线程挂起
- 锁消除：编译器(即时编译器)在运行时，发现某些代码不可能存在共享数据竞争(逃逸分析)，同时又对此代码进行了同步操作，那么会对此锁进行消除
- 锁粗化：大部分时候推荐将同步块的范围限制得尽量小，但是如果循环中有一系列加解锁操作，那么资源消耗可能更大，那么就能够把加锁同步的范围粗化到循环体外，只需加解锁一次
- 轻量级锁(基于：对于绝大部分的锁，在整个同步周期内都是不存在锁竞争的)：在代码即将进入同步块时，如果对象没有被锁定，那么就在栈帧中建立一个锁记录(Lock Record)的空间，用于保存需要锁定的对象头当前的Mark Word拷贝(对象的GC分代信息等)，然后虚拟机将使用CAS操作试图把对象的Mark Word更新为指向Lock Record的指针(因为原本Mark Word中的内容已经被保存好，所以现在可以安全的修改，不会丢失原来的数据)，要是此操作成功，那么表明获取到锁，直接把锁标志位改为00，失败了标识有线程与当前线程竞争，那么先检查对象的Mark Word是否指向当前栈帧，是则表明当前线程已经持有此锁，可能是重入，那么直接进入同步块即可，反之标识这个锁对象已经被其它线程抢占，如果两条以上线程竞争锁，那么锁需要膨胀为重量级锁，状态标志变为10，Mark Word变为指向互斥量(重量级锁)的指针，后面的线程也进入阻塞状态，解锁就是用CAS尝试把现在的Mark Word(指向Lock Record的指针)替换为Lock Record中的记录(GC分代等信息)，成功则完成，失败表明有其余线程尝试过获取锁，因此锁膨胀为重量级，在释放锁的同时还需要唤醒被挂起的线程
- 偏向锁(在无竞争的情况下把整个同步消除)：该锁偏向于第一个获得它的线程，如果接下来的过程没有其它线程获取此锁，那么持有偏向锁的线程将永远不需要进行同步。初次获取锁时，会将此线程ID记录在Mark Word中，之后该线程每次进入此锁相关的同步块时，都无需进行同步操作(加锁、解锁、对Mark Word的更新)，一旦另外的线程尝试获取此锁，那么偏向状态结束，恢复到未锁定或者轻量级锁定状态，后续按照轻量级锁执行，使用-XX:-UseBiasedBlocking禁止偏向锁

**当一个对象已经计算过已一直性哈希码后，它就再也无法进入偏向锁状态了；而当一个处于偏向锁状态的对象需要计算哈希码值时，偏向状态会被立即撤销，并且锁会膨胀为重量级锁，重量级锁对象头指向了重量级锁的位置，对应的重量级锁类ObjectMonitor中有非加锁状态下的Mark Word，里面有原来的哈希码**