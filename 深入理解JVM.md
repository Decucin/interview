# 自动内存管理
## 运行时数据区
- 程序计数器：指示字节码的行号，是程序控制流的指示器，运行的是Java方法记录正在执行的字节码指令地址，本地方法则值是Undefined，唯一一个无OOM的区域，线程私有
- Java虚拟机栈：描述Java方法的线程内存模型，方法被执行对应一个栈帧被创建，栈帧中有局部变量表、操作数栈、动态链接、方法出口等，局部变量表中的变量是以局部变量槽(Slot)的形式展示的，但8个字节的数据类型，long, double占用两个槽，局部变量表的空间(槽的数量)在**编译**时已经确定，规定了两类异常OOM(在运行动态扩展时可能发生，但Hotspot不允许动态扩展，所以出现此问题只可能在申请栈空间时出现)以及SOF，线程私有
- 本地方法栈：与虚拟机栈类似但在运行Native方法是被创建，maybe和Java虚拟机栈合二为一，也有可能OOM以及SOF，线程私有
- 堆：在虚拟机启动时被创建，大多数对象在这里被创建(存在栈上分配以及标量替换)，也叫GC堆，堆所有线程共享，但是存在线程私有分配缓冲区(Thread Local Allocation Buffer, TLAB)用于提升对象分配时的速度。堆可以物理上不连续，但逻辑上应该被视为连续，此外大对象的实现一般需要连续的内存空间，堆中没有完成实例分配同时堆也无法再扩展时会OOM
- 方法区：所以线程共享，存储被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等，也叫Non-Heap，用于和堆区分开，会OOM
  - 之前的永久代实现是方法区，但永久代有最大上限，容易OOM
  - JDK6考虑移除方法区改为本地内存实现
  - JDK7将永久代中的字符串常量池、静态变量等移出
  - JDK8放弃永久代，改为本地内存中实现的元空间(Metaspace)，其中含有JDK7中未移出的信息，主要是类型信息，这里甚至可以不需要垃圾回收
运行时常量池也是方法区的一部分，主要含有常量池表(编译器产生的字面量以及符号引用，可能还有直接引用)，这里的东西其实时动态的，比如String类的intern()，会OOM

此外还有一部分被频繁使用但不属于运行时数据区的内存－－直接内存，NIO中可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为引用进行操作，可以避免在Java堆以及Native堆中拷贝数据产生的开销，这部分内存大小不会受Java堆限制但是会受本机总内存(物理内存、SWAP分区或者分页文件)大小以及处理器寻址空间的限制

## 对象的创建
1. 先检查常量池中是否有类的符号引用
2. 没有则需要先进行类加载过程
3. 有则需要对对象分配内存
   - 指针碰撞：内存是规整的，一部分是使用的，另一部分是未使用的，有一个指针作为两部分区域的分界点，移动这个分界点即可
   - 空闲列表：一个列表中记录了空闲的内存块，分配的时候找到一块足够大的内存空间划分给对象实例
   - 具体使用以上两种内存分配方式取决于堆是否规整，即垃圾收集器是否启用了空间压缩整理的能力
   - 此外，分配空间在并发情况下并不是线程安全的，有两种处理方式，CAS失败重试以及TLAB(哪个线程需要分配内存，就现在其TLAB中分配，TLAB用完了在分配新内存时才CAS失败重试)
4. 将分配到的内存空间初始化零值，使用TLAB则可在TLAB分配时完成
5. 进行必要设置，将对象的信息，如对应的类型、如何找到类的元数据信息、对象hash(第一次调用hashcode()才会被计算)、GC分代、锁信息等存放在对象头
6. 执行< init >()方法   --> 构造函数

## 对象的内存布局
### 对象头(Header)
- 用于存储对象自身的运行数据(hash码, GC分代年龄, 锁状态标志位, 线程持有的锁, 偏向线程ID, 偏向时间戳)    --->    Mark Word（动态定义，根据对象状态复用地址空间）
- 指向对象的类型元数据的类型指针(但这块不是一定的，有的虚拟机实现中对象头中并没有对象的类型指针)
- 如果是数组，还有一块用于记录数组长度(用于推断数组大小，确定Java对象的大小)
### 实例数据(Instance Data)
对象真正存储的有效信息  --->    字段内容(包含从父类中记录下来的)
### 属性填充(Padding)
Hotspot要求任何对象都必须是8字节的倍数，没有对其则通过padding填充
这里为什么要求是8字节的整数倍，找到的有两个原因，一是为了压缩指针时使用都是8的倍数，那么可以把二进制里面的后三位取消，即左移或者右移三位时能够做到这一点，如8(1000) ->  1(1), 16(10000)  -> 2(10)，这样，那么理论上原本可以表示4G的内存现在可以表示32G；第二个原因，大部分都是64位系统，一次读取64bit，即8字节

## 访问对象的方式
通过栈上的refrence数据来操作堆上的具体对象
- 句柄：堆中可能有一块句柄池存储了对象的句柄地址，reference包含了对象实例数据以及实例数据各自具体的地址信息，好处是对象被移动时修改示例数据指针即可，reference本身不需修改
- 直接指针：堆的内存布局需要考虑如何放置访问类型数据的相关信息，reference存储对象地址，好处是速度快，节省了一次指针定位的开销(Hotspot主要使用这个)

# 垃圾收集器与内存分配策略
## 垃圾收集器的任务
1. What
   * 对于线程独有的部分，这些内容随线程的创建而产生，线程结束而消亡，故无需GC
   * 堆和方法区则不一样，故这两部分是垃圾收集器管理的部分
2. When
   * 引用计数法：在对象中添加一个计数器，有一个地方引用时计数器+1，失效时-1，0则不可能再被使用  -->  优点：原理简单，效率高；缺点：有额外情况需要处理(循环引用很麻烦)
   * 可达性分析法：通过GC Roots向下搜索形成引用链，若是有的对象到GC Roots没有引用链相连，那么需要被GC。  -->  主流
可作为GC Roots的基本对象：
   * 虚拟机栈(栈帧中的本地变量表)中引用的对象：各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等
   * 方法区中被类静态属性引用的对象：Java类的引用类型静态变量
   * 方法区中常量引用的对象：字符串常量池里的引用
   * 本地方法栈中JNI引用的对象
   * Java虚拟机内部的引用：基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器
   * 被同步锁(synchronized)持有的对象
   * 反应Java虚拟机内部情况的JMXBean, JVMTI注册的回调, 本地代码缓存等
   * 其他的可能会被临时性假如其中
3. How

## 引用
* JDK1.2之前：如果reference类型的数据中存储的数值是另外一块内存的地址就称为引用
* 对引用进行了扩充：强引用、软引用、弱引用、虚引用

