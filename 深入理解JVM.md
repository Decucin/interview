# 自动内存管理
## 运行时数据区
- 程序计数器：指示字节码的行号，是程序控制流的指示器，运行的是Java方法记录正在执行的字节码指令地址，本地方法则值是Undefined，唯一一个无OOM的区域，线程私有
- Java虚拟机栈：描述Java方法的线程内存模型，方法被执行对应一个栈帧被创建，栈帧中有局部变量表、操作数栈、动态链接、方法出口等，局部变量表中的变量是以局部变量槽(Slot)的形式展示的，但8个字节的数据类型，long, double占用两个槽，局部变量表的空间(槽的数量)在**编译**时已经确定，规定了两类异常OOM(在运行动态扩展时可能发生，但Hotspot不允许动态扩展，所以出现此问题只可能在申请栈空间时出现)以及SOF，线程私有
- 本地方法栈：与虚拟机栈类似但在运行Native方法是被创建，maybe和Java虚拟机栈合二为一，也有可能OOM以及SOF，线程私有
- 堆：在虚拟机启动时被创建，大多数对象在这里被创建(存在栈上分配以及标量替换)，也叫GC堆，堆所有线程共享，但是存在线程私有分配缓冲区(Thread Local Allocation Buffer, TLAB)用于提升对象分配时的速度。堆可以物理上不连续，但逻辑上应该被视为连续，此外大对象的实现一般需要连续的内存空间，堆中没有完成实例分配同时堆也无法再扩展时会OOM
- 方法区：所以线程共享，存储被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等，也叫Non-Heap，用于和堆区分开，会OOM
  - 之前的永久代实现是方法区，但永久代有最大上限，容易OOM
  - JDK6考虑移除方法区改为本地内存实现
  - JDK7将永久代中的字符串常量池、静态变量等移出
  - JDK8放弃永久代，改为本地内存中实现的元空间(Metaspace)，其中含有JDK7中未移出的信息，主要是类型信息，这里甚至可以不需要垃圾回收
运行时常量池也是方法区的一部分，主要含有常量池表(编译器产生的字面量以及符号引用，可能还有直接引用)，这里的东西其实时动态的，比如String类的intern()，会OOM

此外还有一部分被频繁使用但不属于运行时数据区的内存－－直接内存，NIO中可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为引用进行操作，可以避免在Java堆以及Native堆中拷贝数据产生的开销，这部分内存大小不会受Java堆限制但是会受本机总内存(物理内存、SWAP分区或者分页文件)大小以及处理器寻址空间的限制

## 对象的创建
1. 先检查常量池中是否有类的符号引用
2. 没有则需要先进行类加载过程
3. 有则需要对对象分配内存
   - 指针碰撞：内存是规整的，一部分是使用的，另一部分是未使用的，有一个指针作为两部分区域的分界点，移动这个分界点即可
   - 空闲列表：一个列表中记录了空闲的内存块，分配的时候找到一块足够大的内存空间划分给对象实例
   - 具体使用以上两种内存分配方式取决于堆是否规整，即垃圾收集器是否启用了空间压缩整理的能力
   - 此外，分配空间在并发情况下并不是线程安全的，有两种处理方式，CAS失败重试以及TLAB(哪个线程需要分配内存，就现在其TLAB中分配，TLAB用完了在分配新内存时才CAS失败重试)
4. 将分配到的内存空间初始化零值，使用TLAB则可在TLAB分配时完成
5. 进行必要设置，将对象的信息，如对应的类型、如何找到类的元数据信息、对象hash(第一次调用hashcode()才会被计算)、GC分代、锁信息等存放在对象头
6. 执行< init >()方法   --> 构造函数

## 对象的内存布局
### 对象头(Header)
- 用于存储对象自身的运行数据(hash码, GC分代年龄, 锁状态标志位, 线程持有的锁, 偏向线程ID, 偏向时间戳)    --->    Mark Word（动态定义，根据对象状态复用地址空间）
- 指向对象的类型元数据的类型指针(但这块不是一定的，有的虚拟机实现中对象头中并没有对象的类型指针)
- 如果是数组，还有一块用于记录数组长度(用于推断数组大小，确定Java对象的大小)
### 实例数据(Instance Data)
对象真正存储的有效信息  --->    字段内容(包含从父类中记录下来的)
### 属性填充(Padding)
Hotspot要求任何对象都必须是8字节的倍数，没有对其则通过padding填充
这里为什么要求是8字节的整数倍，找到的有两个原因，一是为了压缩指针时使用都是8的倍数，那么可以把二进制里面的后三位取消，即左移或者右移三位时能够做到这一点，如8(1000) ->  1(1), 16(10000)  -> 2(10)，这样，那么理论上原本可以表示4G的内存现在可以表示32G；第二个原因，大部分都是64位系统，一次读取64bit，即8字节

## 访问对象的方式
通过栈上的refrence数据来操作堆上的具体对象
- 句柄：堆中可能有一块句柄池存储了对象的句柄地址，reference包含了对象实例数据以及实例数据各自具体的地址信息，好处是对象被移动时修改示例数据指针即可，reference本身不需修改
- 直接指针：堆的内存布局需要考虑如何放置访问类型数据的相关信息，reference存储对象地址，好处是速度快，节省了一次指针定位的开销(Hotspot主要使用这个)

# 垃圾收集器与内存分配策略
## 垃圾收集器的任务
1. What
   * 对于线程独有的部分，这些内容随线程的创建而产生，线程结束而消亡，故无需GC
   * 堆和方法区则不一样，故这两部分是垃圾收集器管理的部分
2. When
   * 引用计数法：在对象中添加一个计数器，有一个地方引用时计数器+1，失效时-1，0则不可能再被使用  -->  优点：原理简单，效率高；缺点：有额外情况需要处理(循环引用很麻烦)
   * 可达性分析法：通过GC Roots向下搜索形成引用链，若是有的对象到GC Roots没有引用链相连，那么需要被GC。  -->  主流
可作为GC Roots的基本对象：
   * 虚拟机栈(栈帧中的本地变量表)中引用的对象：各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等
   * 方法区中被类静态属性引用的对象：Java类的引用类型静态变量
   * 方法区中常量引用的对象：字符串常量池里的引用
   * 本地方法栈中JNI引用的对象
   * Java虚拟机内部的引用：基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器
   * 被同步锁(synchronized)持有的对象
   * 反应Java虚拟机内部情况的JMXBean, JVMTI注册的回调, 本地代码缓存等
   * 其他的可能会被临时性假如其中
3. How

## 引用
* JDK1.2之前：如果reference类型的数据中存储的数值是另外一块内存的地址就称为引用
* 对引用进行了扩充：强引用、软引用、弱引用、虚引用

1. 强引用
无论任何情况下，只要强引用关系存在，垃圾回收器用友不会回收掉被引用的对象  --> 引用赋值
2. 软引用
系统将要发生内存溢出时这些内陷会被回收  --> 缓存
3. 弱引用
只能存活到下一次垃圾收集发生为止  --> ThreadLocal
4. 虚引用
不会对被引用对象产生影响同时无法通过虚引用取得对象实例  --> 在对象被回收时得到一个通知

## "缓刑"
1. 可达性分析后，被判定为不可达对象，此时是其第一次被标记，之后进行一次筛选，判断该对象是否有必要执行finalize() (没有重写该方法或者该方法被调用过则不需执行)
2. 需要执行该方法的对象会被放置在F-Queue队列中，并在之后由一条虚拟机自动建立，调度优先级比较低的Finalizer线程去执行对应方法，但是只是让该方法开始，不承诺；一定会等待其运行结束(防止该方法执行慢或者死循环导致队列中其他对象的方法无法被执行)
3. 该方法执行后，收集器会对F-Queue中的对象进行第二次小规模标记，判定是否需要被GC

## 方法区的回收
主要的回收类型：废弃的常量、不再被使用的类型
1. 废弃的常量
某个字符串曾进入过常量池但现在没有任何对象引用该常量，同时也没有其它地方引用此字面量
2. 不再被使用的类型
   * 所有实例都被回收
   * 该类的类加载器已被回收
   * 对应的Class对象没有在任何地方被引用
   * 满足以上条件仅是被允许，是否对类型进行回收可以通过-Xnoclassgc控制

## 垃圾收集算法
分代假说：
1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
基于以上分代假说，一般采取的是：将堆分为不同区域，将对象根据年龄分到不同区域存储(划分为年轻代和老年代)
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数(防止每次GC都要遍历老年代)
在新生代上建立一个全局数据结构(记忆集Remembered Set)。该结构把老年代划分成若干块，标识出老年代的哪一块会存在跨代引用，此后若是Minor GC，那么包含跨代引用的那一块才会被加入到GC Roots扫描

对收集的定义：
* 部分收集(Partial GC)：不完整收集整个堆
    * 新生代收集(Minor GC/Young GC)：目标是新生代
    * 老年代收集(Major GC/Old Gc)：目标是老年代(CMS有)
    * 混合收集(Mixed GC)：目标是整个新生代和部分老年代(G1)
* 整堆收集(Full GC)：收集整个Java堆和方法区

### 标记——清除
1. 标记所有需要回收的对象
2. 统一回收掉所有被标记的对象
3. 当然也可以反过来，标记存活的，回收未被标记的

缺点：
* 执行效率不稳定：标记、清除的效率随对象增长而降低
* 内存碎片：产生大量内存碎片，碎片太多可能导致之后需要分配大对象时无法找到足够的连续内存而提前触发另一场垃圾收集

### 标记——复制
1. 将可用内存分为大小相等的两块，每次使用一块
2. 被使用的那块内存使用完成之后，将存活的对象复制到另外一块上
3. 把之前的那块内存一次性清理掉

缺点：
* 如果多数对象是存活的，那么会产生大量内存复制的开销
* 可用内存缩减为原来的一半

Appel式回收
1. 把新生代划分为一块较大的Eden和两块较小的Survivor
2. 分配时只使用Eden和一块Survivor
3. 回收时将Eden和使用的那块Survivor中存活的对象一次性复制到另一块Survivor
4. 清理掉Eden区和使用过的Survivor
5. Eden和Survivor默认是8：1，每次使用90%
6. 若是Survivor的空间(10%)无法容纳，那么需要依赖其他区域(老年代)进行分配担保：没有足够空间存放上次存活下来的存活对象，那么这些对象会通过分配担保机制直接进入老年代

### 标记——整理
1. 标记所有需要回收的对象
2. 让所有存活对象向内存的一端移动
3. 清理掉边界之外的内存

缺点：
* 内存回收时需要进行移动，STW(Stop The World)

和稀泥方法
1. 多数时间标记——清除，容忍碎片
2. 内存碎片影响大对象分配时采用标记——整理清理一次，获得规整的空间(CMS)

## HotSpot垃圾收集器
* Young generation: Serial, ParNew, Parallel Scavenge
* Tenured generation: CMS, Serial Old, Parallel Old
* G1
* 配合使用：Serial + Serial Old, ParNew + CMS(+ Serial Old), Parallel Scavenge + Serial Old, Parallel Scavenge + Parallel Old, G1
  ![配合使用](https://blogs.oracle.com/jonthecollector/our_collectors)
### Serial
* 新生代复制算法暂停所有用户线程
* 客户端模式下默认新生代收集器
* 简单而高效：额外内存占用最小，单线程无需线程切换

### ParNew
* 新生代多条线程垃圾收集(并行收集)，暂停所有用户线程
* 其余与Serial一致
* 除了Serial之外唯一能和CMS协同工作的收集器

### Parallel Scavenge
* 新生代多条GC线程(并行收集)，复制算法暂停所有用户线程
* 达到可控的吞吐量: 用户代码运行时间 / (用户代码运行时间 + 垃圾收集运行时间)，此收集器可以使用自适应调节策略调节堆的各种参数

### Serial Old
* Serial的老年代版本
* 单线程收集，标记——整理，暂停所有用户线程
* 主要提供给客户端模式下的虚拟机使用，若是在服务端用，要么和Parallel Scavenge配合使用，要么CMS并发收集失败(Concurrent Mode Failure)时使用

### Parallel Old
* Parallel的老年代版本
* 多线程并发收集，标记整理算法，暂停所有用户线程
* 吞吐量优先

### CMS
* 回收停顿时间最短
* 过程：
  1. 初始标记：标记GC Roots直接关联的对象，很快，STW
  2. 并发标记：从直接关联对象遍历整个对象图，耗时长但无需暂停用户线程
  3. 重新标记：因2中用户线程继续工作，导致标记产生变动(增量更新)，暂停时间比1稍长但远比2短
  4. 并发清除：清理掉死亡对象，和用户线程并发
* 缺点：
  1. 资源敏感：不会导致用户线程暂停，但是会因为占用处理器计算能力导致应用程序变慢，降低总吞吐量，随着核心数量增加而降低
  2. 无法处理浮动垃圾：并发标记以及并发清除阶段产生的对象只有等下一次GC(对象朝生夕灭)(对于这部分可能会产生的对象，需要分配预留空间)，CMS运行期间若是预留空间不足会导致并发失败，之后使用Serial Old重新进行老年代回收
  3. 产生大量空间碎片：标记——清除，这会导致还有空间但是不连续，分配大对象时空间不足进行Full GC空间整理

### Garbage First(G1)
* JDK9之后服务端默认的垃圾回收器
* 把连续的Java堆划分为多个大小相等的独立空间区域(Region)
* 每个Region都可作为Eden, Survivor, 老年代
* 特殊的Humongous专门存储大对象
* 过程如下：
  1. 初始标记：标记GC Roots直连的对象，修改TAMS的值，需要停顿用户线程但耗时很短，而且是借用Minor GC时同步完成
  2. 并发标记：进行可达性分析，扫描对象图，耗时长但可与用户线程并发，重新处理SATB记录在并发下有引用变动的记录
  3. 最终标记：暂停用户线程，处理2过程留下的少量SATB记录
  4. 筛选回收：更新Region统计记录，对Region排序，制定回收计划，任意选择Region进行回收，把需要回收的Region中的存活对象复制到空Region中，清理掉整个旧Region，暂停用户线程但多条GC线程并行执行
* 核心问题如下：
  1. 跨Region的引用如何解决：每个Region有自己的记忆集，每个记忆集存有其它Region指向本Region的指针，并标记这些指针在哪些卡页中(记忆集本质上是一个Hash表，key是别的Region的起始地址，Value是一个集合，存储了卡表的索引号)，导致了更高的内存占用
  2. 并发标记阶段如何保证GC线程与用户线程互不干扰(两方面内容)：一是用户线程改变引用时不能打破原本的对象图结构，通过原始快照实现，二是新创建的对象如何分配内存，通过在每个Region中设置两个TAMS(Top at Mark Start)指针，新生成的对象在这里分配地址，默认其存活
  3. 如何建立预测模型：衰减均值理论，记录每个Region的回收耗时、脏卡数量等，统计状态越新，越能决定回收价值

CMS与G1的比较：
* G1不会产生空间碎片，可以制定最大停顿时间，分Region布局
* G1的卡表更复杂，内存占用更高(CMS只要一份，同时只需要处理老年代到新生代的引用)，执行负载也更高(CMS只使用写后屏障，G1还要使用写前屏障)

### Shenandoah
* 非官方，Oracle通过条件编译排除了其代码，只在OpenJDK中有
* 类似G1，但有改进：
  1. 支持并发收集
  2. 默认不使用分代收集
  3. 用连接矩阵代替记忆集记录跨Region引用
* 过程如下：
  1. 初始标记：标记与GC Roots直连的对象，STW
  2. 并发标记：遍历对象图，标出全部可达对象，与用户线程并发执行
  3. 最终标记：处理剩余的SATB，统计价值最高的Region，构成一组回收集，有短暂的停顿
  4. 并发清理：清理没有一个存活对象的Region
  5. 并发回收：把Region中的存活对象复制到其它未被使用的Region中(注意此时用户线程是继续运行的，收集器通过读屏障(后面希望改为引用访问屏障)和转发指针(对象头多一个Brooks Pointer，原本指向自己，之后指向要转发的地址，类似句柄)完成)
  6. 初始引用更新：建立一个线程集合点，确保5已经完成，有短暂停顿
  7. 并发引用更新：把堆中所有指向旧对象的引用修正到复制后的新地址，按照内存物理地址的顺序线性搜索即可
  8. 最终引用更新：修正存在与GC Roots的引用，短暂停顿
  9. 并发清理：回收整个回收集中的Region

### ZGC
* 基于Region布局，分为大(容量动态变化但必须是2MB的整数倍，放置4MB以上的大对象), 中(容量固定为32MB，存放大于等于256KB但小于4MB的对象), 小(容量固定为2MB，放置小于256KB的对象)
* 过程：
  1. 初始标记：标记GC Roots直连对象，STW
  2. 并发标记：可达性分析并初始标记、最终标记短暂停顿，标记过程实际就是更新染色指针的Marked 0, Marked 1位
  3. 并发预报重分配：得出本次需回收哪些Region，组成重分配集
  4. 并发重分配：把重分配集中的存活对象复制到新Region上，为该集中的每个Region设立一个转发表记录就对象到新对象的转发关系(指针自愈：访问发现此对象处于重分配集，那么会被读屏障拦下并访问到新复制的对象，同时修改该引用的值，使其直接指向新对象)
  5. 并发重映射：修正整个堆中指向重分配集中旧对象的引用(因为指针可以自愈，故把这个步骤合并到并发标记阶段)
* 核心是如何实现并发整理——指针染色
64位系统中理论可访问2^64字节的内存，但AMD64架构中最多只支持52位地址总线和48位虚拟地址空间，此外操作系统也会限制，故64位Linux只支持47位进程虚拟地址空间和46位物理地址空间，那么把这46位的高四位拿出分别记为Finalizable(只能通过finalize()访问)，Remapped(是否进入了重分配集(是否被移动过))，Marked 0, Marked 1(三色标记状态)
为什么可以这样呢？因为这些标记只于引用有关，与对象本身无关
* 染色指针的三大优势
  1. 存活对象被移走后可以马上被释放或者重用
  2. 大幅减少垃圾收集过程中内存屏障的使用情况(只使用读屏障)
  3. 染色指针日后也可扩展
* 问题：染色指针操作系统是否支持
* 还有一个优点：支持"NUMA-Aware"(为多处理器或多核处理器所设计的内存架构)内存分配，优先尝试在请求线程当前所处的处理器本地内存上分配对象以保证高效内存访问