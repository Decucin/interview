# 自动内存管理
## 运行时数据区
- 程序计数器：指示字节码的行号，是程序控制流的指示器，运行的是Java方法记录正在执行的字节码指令地址，本地方法则值是Undefined，唯一一个无OOM的区域，线程私有
- Java虚拟机栈：描述Java方法的线程内存模型，方法被执行对应一个栈帧被创建，栈帧中有局部变量表、操作数栈、动态链接、方法出口等，局部变量表中的变量是以局部变量槽(Slot)的形式展示的，但8个字节的数据类型，long, double占用两个槽，局部变量表的空间(槽的数量)在**编译**时已经确定，规定了两类异常OOM(在运行动态扩展时可能发生，但Hotspot不允许动态扩展，所以出现此问题只可能在申请栈空间时出现)以及SOF，线程私有
- 本地方法栈：与虚拟机栈类似但在运行Native方法是被创建，maybe和Java虚拟机栈合二为一，也有可能OOM以及SOF，线程私有
- 堆：在虚拟机启动时被创建，大多数对象在这里被创建(存在栈上分配以及标量替换)，也叫GC堆，堆所有线程共享，但是存在线程私有分配缓冲区(Thread Local Allocation Buffer, TLAB)用于提升对象分配时的速度。堆可以物理上不连续，但逻辑上应该被视为连续，此外大对象的实现一般需要连续的内存空间，堆中没有完成实例分配同时堆也无法再扩展时会OOM
- 方法区：所以线程共享，存储被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等，也叫Non-Heap，用于和堆区分开，会OOM
  - 之前的永久代实现是方法区，但永久代有最大上限，容易OOM
  - JDK6考虑移除方法区改为本地内存实现
  - JDK7将永久代中的字符串常量池、静态变量等移出
  - JDK8放弃永久代，改为本地内存中实现的元空间(Metaspace)，其中含有JDK7中未移出的信息，主要是类型信息，这里甚至可以不需要垃圾回收
运行时常量池也是方法区的一部分，主要含有常量池表(编译器产生的字面量以及符号引用，可能还有直接引用)，这里的东西其实时动态的，比如String类的intern()，会OOM

此外还有一部分被频繁使用但不属于运行时数据区的内存－－直接内存，NIO中可以使用Native函数库直接分配堆外内存，然后通过DirectByteBuffer对象作为引用进行操作，可以避免在Java堆以及Native堆中拷贝数据产生的开销，这部分内存大小不会受Java堆限制但是会受本机总内存(物理内存、SWAP分区或者分页文件)大小以及处理器寻址空间的限制

## 对象的创建
1. 先检查常量池中是否有类的符号引用
2. 没有则需要先进行类加载过程
3. 有则需要对对象分配内存
   - 指针碰撞：内存是规整的，一部分是使用的，另一部分是未使用的，有一个指针作为两部分区域的分界点，移动这个分界点即可
   - 空闲列表：一个列表中记录了空闲的内存块，分配的时候找到一块足够大的内存空间划分给对象实例
   - 具体使用以上两种内存分配方式取决于堆是否规整，即垃圾收集器是否启用了空间压缩整理的能力
   - 此外，分配空间在并发情况下并不是线程安全的，有两种处理方式，CAS失败重试以及TLAB(哪个线程需要分配内存，就现在其TLAB中分配，TLAB用完了在分配新内存时才CAS失败重试)
4. 将分配到的内存空间初始化零值，使用TLAB则可在TLAB分配时完成
5. 进行必要设置，将对象的信息，如对应的类型、如何找到类的元数据信息、对象hash(第一次调用hashcode()才会被计算)、GC分代、锁信息等存放在对象头
6. 执行< init >()方法   --> 构造函数

## 对象的内存布局
### 对象头(Header)
- 用于存储对象自身的运行数据(hash码, GC分代年龄, 锁状态标志位, 线程持有的锁, 偏向线程ID, 偏向时间戳)    --->    Mark Word（动态定义，根据对象状态复用地址空间）
- 指向对象的类型元数据的类型指针(但这块不是一定的，有的虚拟机实现中对象头中并没有对象的类型指针)
- 如果是数组，还有一块用于记录数组长度(用于推断数组大小，确定Java对象的大小)
### 实例数据(Instance Data)
对象真正存储的有效信息  --->    字段内容(包含从父类中记录下来的)
### 属性填充(Padding)
Hotspot要求任何对象都必须是8字节的倍数，没有对其则通过padding填充
这里为什么要求是8字节的整数倍，找到的有两个原因，一是为了压缩指针时使用都是8的倍数，那么可以把二进制里面的后三位取消，即左移或者右移三位时能够做到这一点，如8(1000) ->  1(1), 16(10000)  -> 2(10)，这样，那么理论上原本可以表示4G的内存现在可以表示32G；第二个原因，大部分都是64位系统，一次读取64bit，即8字节

## 访问对象的方式
通过栈上的refrence数据来操作堆上的具体对象
- 句柄：堆中可能有一块句柄池存储了对象的句柄地址，reference包含了对象实例数据以及实例数据各自具体的地址信息，好处是对象被移动时修改示例数据指针即可，reference本身不需修改
- 直接指针：堆的内存布局需要考虑如何放置访问类型数据的相关信息，reference存储对象地址，好处是速度快，节省了一次指针定位的开销(Hotspot主要使用这个)

# 垃圾收集器与内存分配策略
## 垃圾收集器的任务
1. What
   * 对于线程独有的部分，这些内容随线程的创建而产生，线程结束而消亡，故无需GC
   * 堆和方法区则不一样，故这两部分是垃圾收集器管理的部分
2. When
   * 引用计数法：在对象中添加一个计数器，有一个地方引用时计数器+1，失效时-1，0则不可能再被使用  -->  优点：原理简单，效率高；缺点：有额外情况需要处理(循环引用很麻烦)
   * 可达性分析法：通过GC Roots向下搜索形成引用链，若是有的对象到GC Roots没有引用链相连，那么需要被GC。  -->  主流
可作为GC Roots的基本对象：
   * 虚拟机栈(栈帧中的本地变量表)中引用的对象：各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等
   * 方法区中被类静态属性引用的对象：Java类的引用类型静态变量
   * 方法区中常量引用的对象：字符串常量池里的引用
   * 本地方法栈中JNI引用的对象
   * Java虚拟机内部的引用：基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器
   * 被同步锁(synchronized)持有的对象
   * 反应Java虚拟机内部情况的JMXBean, JVMTI注册的回调, 本地代码缓存等
   * 其他的可能会被临时性假如其中
3. How

## 引用
* JDK1.2之前：如果reference类型的数据中存储的数值是另外一块内存的地址就称为引用
* 对引用进行了扩充：强引用、软引用、弱引用、虚引用

1. 强引用
无论任何情况下，只要强引用关系存在，垃圾回收器用友不会回收掉被引用的对象  --> 引用赋值
2. 软引用
系统将要发生内存溢出时这些内陷会被回收  --> 缓存
3. 弱引用
只能存活到下一次垃圾收集发生为止  --> ThreadLocal
4. 虚引用
不会对被引用对象产生影响同时无法通过虚引用取得对象实例  --> 在对象被回收时得到一个通知

## "缓刑"
1. 可达性分析后，被判定为不可达对象，此时是其第一次被标记，之后进行一次筛选，判断该对象是否有必要执行finalize() (没有重写该方法或者该方法被调用过则不需执行)
2. 需要执行该方法的对象会被放置在F-Queue队列中，并在之后由一条虚拟机自动建立，调度优先级比较低的Finalizer线程去执行对应方法，但是只是让该方法开始，不承诺；一定会等待其运行结束(防止该方法执行慢或者死循环导致队列中其他对象的方法无法被执行)
3. 该方法执行后，收集器会对F-Queue中的对象进行第二次小规模标记，判定是否需要被GC

## 方法区的回收
主要的回收类型：废弃的常量、不再被使用的类型
1. 废弃的常量
某个字符串曾进入过常量池但现在没有任何对象引用该常量，同时也没有其它地方引用此字面量
2. 不再被使用的类型
   * 所有实例都被回收
   * 该类的类加载器已被回收
   * 对应的Class对象没有在任何地方被引用
   * 满足以上条件仅是被允许，是否对类型进行回收可以通过-Xnoclassgc控制

## 垃圾收集算法
分代假说：
1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
基于以上分代假说，一般采取的是：将堆分为不同区域，将对象根据年龄分到不同区域存储(划分为年轻代和老年代)
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数(防止每次GC都要遍历老年代)
在新生代上建立一个全局数据结构(记忆集Remembered Set)。该结构把老年代划分成若干块，标识出老年代的哪一块会存在跨代引用，此后若是Minor GC，那么包含跨代引用的那一块才会被加入到GC Roots扫描

对收集的定义：
* 部分收集(Partial GC)：不完整收集整个堆
    * 新生代收集(Minor GC/Young GC)：目标是新生代
    * 老年代收集(Major GC/Old Gc)：目标是老年代(CMS有)
    * 混合收集(Mixed GC)：目标是整个新生代和部分老年代(G1)
* 整堆收集(Full GC)：收集整个Java堆和方法区

### 标记——清除
1. 标记所有需要回收的对象
2. 统一回收掉所有被标记的对象
3. 当然也可以反过来，标记存活的，回收未被标记的

缺点：
* 执行效率不稳定：标记、清除的效率随对象增长而降低
* 内存碎片：产生大量内存碎片，碎片太多可能导致之后需要分配大对象时无法找到足够的连续内存而提前触发另一场垃圾收集

### 标记——复制
1. 将可用内存分为大小相等的两块，每次使用一块
2. 被使用的那块内存使用完成之后，将存活的对象复制到另外一块上
3. 把之前的那块内存一次性清理掉

缺点：
* 如果多数对象是存活的，那么会产生大量内存复制的开销
* 可用内存缩减为原来的一半

Appel式回收
1. 把新生代划分为一块较大的Eden和两块较小的Survivor
2. 分配时只使用Eden和一块Survivor
3. 回收时将Eden和使用的那块Survivor中存活的对象一次性复制到另一块Survivor
4. 清理掉Eden区和使用过的Survivor
5. Eden和Survivor默认是8：1，每次使用90%
6. 若是Survivor的空间(10%)无法容纳，那么需要依赖其他区域(老年代)进行分配担保：没有足够空间存放上次存活下来的存活对象，那么这些对象会通过分配担保机制直接进入老年代

### 标记——整理
1. 标记所有需要回收的对象
2. 让所有存活对象向内存的一端移动
3. 清理掉边界之外的内存

缺点：
* 内存回收时需要进行移动，STW(Stop The World)

和稀泥方法
1. 多数时间标记——清除，容忍碎片
2. 内存碎片影响大对象分配时采用标记——整理清理一次，获得规整的空间(CMS)