# 图

## 生成最小生成树

### Kruscal算法（边）

每次只加入最小的边，加上此边之后若是未形成环则添加这条边。

对于有环无环的判断，可以使用并查集（有两个函数，第一个判断两个集合是否是同一个，直接比较地址即可，另一个是把一个集合中的所有元素添加到另一个集合中），那么算法在执行的过程中只需要先判断该条边两侧的点集是否是同一个，若是则说明有环，不可以将当前边放入，若不是则说明无环，将当前边放入，并让边两侧的集合为同一个。

### Prim算法（点）

初始时点集合为空，首先随便选一个点，并把此节点连接的边解锁，选择解锁的边中最小的一条边，判断该条边连接的点是否已经被选取，若是则跳过继续，若还未被选取则把该点以及对应的边加入到选取的点集中，循环直到所有点都被加入。

所有被解锁的边放入小根堆中，选出堆顶元素，若是该边to元素在边的集合中，那么不要这条边，反之则要这条边并且把以to元素作为起始节点的边加入到堆中。

## 单源最短路径问题

### Dijkstra算法

有一张表，只有到出发点距离为0，其余全为无穷大，之后每次在这个表中选出值最小的那个，判断能否通过这个点更新出发点到其它节点的距离，完成之后将这个点封锁，直至所有的点都被封锁。

这张表可以是哈希表（key为Node，value为目前已经发现的最小距离），距离为无穷大的实现为Map中没有这个节点，如何对点进行封锁，直接把该点放到集合中，若是该点在封锁集合中表示已经被锁，未在其中表示未被锁。

## 拓扑排序

先从所有点集中选出入度为0的点，之后去掉该点以及以该点为起点的边，一直循环选出入度为0的点（出队）并消除其影响，直到最后没有入度为0的点了。

inMap表示当前剩余的入度（key为Node，value为入度）

一个队列表示入度为0的全部点

擦除影响的过程就是对该点的所有next点进行遍历并在inMap中把其value值减一，若是减一之后为0，那么将该点加入到空的队列中。

# 前缀树

1. 判断之前是否加过某个字符串
2. 判断是否有以该字符串为前缀的字符串，若是有，有多少个