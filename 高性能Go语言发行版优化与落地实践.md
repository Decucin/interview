# 高性能Go语言发行版优化与落地实践

* what: 提升软件处理能力，减少不必要开销
* why: 提升用户体验，提高资源利用率

## 内存管理优化

### 自动内存管理

此项管理的是动态内存，由程序语言的运行时系统管理动态内存，避免手动内存管理，防止内存泄漏等问题，需要针对不同的对象完成不同的任务: 为新对象分配空间，找到存活对象以及回收死亡对象的内存空间。

相关概念

* Mutator: 业务线程，分配新对象，修改指向关系
* Collector: GC线程，找到存活对象，回收死亡对象的空间
* Serial GC: 只有一个GC
* Parallel GC: 支持多个Colletors同时回收的GC算法
* Concurrent GC: 业务线程和GC线程可以同时执行

GC的步骤：

* 标记根对象：静态变量、全局变量、常量、线程栈等
* 标记：找到可达对象、
* 清理：所有不可达的对象

### Go内存管理机制

需要提前将内存分块：

* noscan mspan: 用于分配不包含指针的对象，GC无需扫描
* scan mspan: 分配包含指针的对象，GC需要扫描

为内存分配做了缓存，先在mcache上分配，若是当前mcache的mscan分配完毕，那么向mcentral申请带有未分配块的mspan，mspan中没有分配的对象时，会被缓存在mcentral中，而不是立刻释放

优化：Balanced GC

* 申请一块空间GAB用于分配<128B的noscan对象
* 用base, end, top三个指针实现（指针碰撞风格）
* 当这部分空间占用达到某个阈值时，考虑将该空间中存活的对象分配到Survivor GAB中

## 编译器优化

### 编译器和静态分析

静态分析：不执行代码，推导程序行为，分析程序性质

* 控制流分析：程序执行流程
* 数据流分析：数据在控制流上的传递

### Go编译器优化

Tradeoff: 用编译时间换取高效字节码

函数内联：将被调用的函数的函数体的副本替换到调用位置上，同时重写代码以反映参数的绑定

* 优点：消除函数调用开销，例如传递参数、保存寄存器；将过程间分析（比较复杂）转化为过程内分析，帮助其他优化，例如逃逸分析
* 缺点：函数体变大，编译生成的Go镜像变大

Beast mode: 调整函数内联的策略，使更多函数被内联。

逃逸分析：分析代码中指针的动态作用域，即指针可以在何处被访问

* 从对象分配处出发沿着控制流观察数据流
* 若指针p在当前作用域s：
  * 作为参数传递给其它函数
  * 传递给全局变量
  * 传递给其它的goroutine
  * 传递给已逃逸的指针指向的对象
* 则指针p指向的对象逃逸出s，反之没有逃逸出

优化：未逃逸的对象可以在栈上进行分配（在栈上分配很快，降低GC负担）